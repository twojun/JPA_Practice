# 1. 엔티티 설계, 주의사항 - (내용 수정 필요)</br> 
1-1. 외래 키를 보유한 곳을 연관관계의 주인으로 설정한다.</br>
(1) Reference : https://github.com/twojun/ex1-hello-jpa</br></br></br></br>




1-2. 엔티티 클래스는 가급적이면 Setter를 열지 않는다.</br>
(1) Getter는 열지만, Setter는 필요한 상황이 아니라면 가급적 열지 않는다.</br></br>

(2) 실무에서 데이터 조회는 매우 빈번한 일이므로 Getter의 경우 모두 열어두는 편이 편리하다.</br>
(단순 getter 조회만으로 큰 문제가 발생하진 않는다.</br></br>

(3) 하지만 setter는 데이터 변경을 발생시키므로 추후 미래에 엔티티에 대한 데이터가 수정된 경로를 추적하기 매우 어려워진다.(유지보수가 어려워짐)</br></br>

(4) 따라서 엔티티 변경 시 setter 대신에  변경 지점이 명확하도록 변경을 위한 비즈니스 메서드를 별도로 제공하는 것이 좋다.</br></br></br></br>




1-3. 실무에서 다대다 연관관계(N:M), @ManyToMany를 사용하지 않는다.</br>
(1) 따라서 중간 엔티티를 만들고 @ManyToOne, @OneToMany로 매핑해서 사용한다.(다대다 매핑을 일대다, 다대일 매핑으로 풀어낸다.)</br></br></br></br>



1-4. 값 타입은 변경 불가능하게 설계해야 한다.</br>
(1) @Setter를 제거하고 생성자에서 모두 값을 초기화하도록 하여 변경 불가능한 클래스로 설계한다. JPA 스펙상, 엔티티나 임베디드 타입은 자바 기본 생성자의
접근 제어자는 public or protected로 설정한다. </br></br>

(2) JPA가 이러한 제약을 설정한 이유는 JPA 구현 라이브러리가 객체 생성 시 리플렉션과 같은 기술을 사용할 수 있도록 지원해야 하기 때문</br></br></br></br>



1-5. 모든 연관관계는 지연 로딩(Lazy Loading)으로 설정한다.</br>
(1) 즉시 로딩은 어떠한 SQL이 실행될지 추적하기 어렵다. em.find()와 같은 단순 단건 조회가 아닌 JPQL을 실행하는 상황에서 N+1 문제를 발생시킨다.</br></br>

(2) 실무에서 모든 연관관계는 LAZY로 잡는다.</br></br>

(3) 연관 엔티티를 함께 조회해야 한다면 Fetch join, Entity graph 기능을 사용하여 최적화한다.
- fetch join : 특정 context에서 필요한 부분들을 별도로 가져오는 방법</br></br>

(4) @XToOne 어노테이션의 기본 로딩 전략은 EAGER이므로 직접 LAZY로 설정해야 한다.
- @XToMany 어노테이션은 기본 전략이 LAZY로 설정되어 있다. </br></br></br></br>




1-6. 컬렉션은 필드에서 초기화한다.</br>
(1) Best practice의 경우, 컬렉션은 필드에서 바로 초기화하는 것이 null 문제 등을 고려해 봤을 때 가장 안전하다.</br></br>

(2) Hibernate의 경우 엔티티 영속화 시, 컬렉션을 hibernate가 제공하는 내부 컬렉션으로 변경하게 된다.</br>
- 하이버네이트가 관리하는 별도의 컬렉션으로 변경되었기 때문에 사용자가 임의의 메서드를 통해 접근하거나 값을 수정, 컬렉션을 생성하고자 한다면 내부 메커니즘이 영향을 받아 정상 동작하지 않을 수도 있다.
- 따라서 필드 레벨에서 초기화하는 것이 안전하고 코드가 간결하다. </br></br></br></br>




1-7. 테이블, 컬럼명 생성 전략(스프링 부트 사용 시)</br>
(1) 자바의 camel case -> under score 방식으로 전환됨</br></br>
(2) .(dot) -> under score</br></br>
(3) 대문자 -> 소문자</br></br></br></br>




1-8. 연관관계 편의 메서드 </br>
(1) 연관관계 편의 메서드의 경우 양방향 연관관계가 설정된 엔티티 간 데이터의 동기화를 위해 사용된다. </br></br>
(2) 사용 시 코드의 가독성 향상, 연관관계를 변경해야 할 때 한쪽만 수정하면 된다는 장점 존재 </br></br>
(3) 비즈니스의 핵심 로직이 존재하는 엔티티에 연관관계 메서드를 구현하는 것이 일반적이다. </br></br></br></br></br></br>






# 2. 도메인 개발, 테스트 </br>
2-1 @Autowired</br>
(1) 스프링이 Dependency injection 기능을 수행하기 위한 어노테이션 </br></br>

(2) 일반적으로 스프링 빈으로 등록된 클래스이거나 @Component, @Service, @Repository, @Controller 등의 어노테이션으로 등록된 클래스, @Configuration으로 등록된 클래스 내부의 빈을
주입시킬 수 있다.</br></br></br></br>





2-2. @Transactional</br>
(1) JPA의 모든 데이터 변경은 트랜잭션 내부에서 진행되어야 한다.</br></br>

(2) @Transactional(readOnly = true) 어노테이션은 조회 서비스에서 성능을 최적화한다. 따라서 조회 메서드인 경우 해당 옵션을 추가해주면 좋다. </br></br></br></br>




2-3. @AllArgsConstructor, @RequiredArgsConstructor </br>
(1) 공통적으로 두 어노테이션은 Lombok 라이브러리에서 제공하는 기능으로, 생성자를 기본으로 만들어주는 기능이다.</br></br>

(2) 차이점은, @AllArgsConstructor은 모든 필드를 파라미터로 받는 생성자를 만들고,  @RequiredArgsConstructor은 @NotNull 또는 final로
선언된 필드만을 생성자의 파라미터로 받게 된다. 필드의 선언 방식에 따라 결정되는 파라미터들이 달라지는 것이 두 어노테이션의 차이점이라고 볼 수 있다. </br></br></br></br></br>





2-4. 테스트 </br>
(1) given / when / then</br>
- given : ~이 주어질 때,
- when : ~으로 처리하면,
- then : ~한 결과가 예상된다.</br></br></br>


(2) 테스트 과정에서 실제 사용하는 외부 DB가 아닌 완전히 격리된 환경인 In-memory DB를 사용하는 방법(스프링 부트)</br>
- build.gradle에서 dependencies에 runtimeOnly 'com.h2database:h2' 필드가 존재하는 경우</br>
- main이 아닌 test 디렉토리에 resource/application.yml을 생성한다.</br>
- datasource/url 영역을 jdbc:h2:mem:test으로 설정하면 외부 데이터베이스가 없어도 인메모리 데이터베이스 환경에서 테스트를 할 수 있다.</br>
- 만약 스프링 부트를 사용한다면 위와 같은 설정이 없어도 테스트를 인메모리 DB 환경에서 동작하도록 설계되어 있다.</br></br></br>



(3) Assertions.assertEquals()</br>
- 해당 메서드의 경우 테스트 프레임워크에서 사용되는 메서드로, 두 값을 비교하여 그 결과가 같은지 확인하는 데 사용된다.
  이 메서드는 예상 값(expected value)과 실제 값(actual value)을 비교하여 두 값이 동일한지 확인하고, 만약 값이 다르다면 테스트가 실패하게 된다.</br></br></br></br>




2-5. 도메인 주도 설계(엔티티) </br>
(1) 객체지향적으로 생각해 보면 데이터(필드)를 가지고 있는 도메인(엔티티)가 핵심 비즈니스 로직을 담고 있는 설계가 응집력이 좋은 설계이다.</br></br>

(2) (객체지향적 설계) 데이터를 변경할 경우 @Setter를 사용하는 것이 아닌 도메인에 핵심 비즈니스 로직을 담은 메서드를 통해 변경하는 것이 바람직하다.</br></br>

(3) 엔티티에 특정 엔티티의 비즈니스와 관련된 로직을 추가하는 것은 도메인 주도 설계의 한 방법으로 코드의 응집성, 재사용성, OOP의 핵심 내용 중 하나인 
단일 책임 원칙(SRP, 특정 엔티티 내부에 관련 로직들이 캡슐화되어 있음)을 준수하는 데 도움이 된다.</br></br>

(4) 비즈니스 로직이 대부분 엔티티에 존재하고, 서비스 계층은 단순히 엔티티에 필요한 요청을 위임하는 역할을 하는데 이처럼 엔티티가 비즈니스 로직(상태와 행위)을 가지고 객체지향의 특성을
활용하는 것을 Domain Model Pattern이라고 하고, 반대로 엔티티에 비즈니스 로직이 거의 없고 서비스 계층에서 대부분 비즈니스 로직을 처리하는 것을 
Transaction Script Pattern이라고 한다. JPA와 같은 ORM 기술을 사용할 때는 Transaction Script Pattern보다는 Domain Model Pattern 방법을 채택해서 
대부분 설계한다. 각각 장단점이 존재하기 때문에 상황에 따라 설계 방법을 고민해본다. </br></br>

(5) Domain Model Pattern을 사용하면 Repository와 관계없이 관련 엔티티에 대해 바로 테스트를 작성할 수 있다.</br></br>

(6) Cascade 전파 옵션의 경우, 라이프 사이클에 대해서 다른 연관된 엔티티도 동일하게 관리할 수 있을 때 사용하는 것이 좋다.</br></br>

(7) 특정 객체를 생성해야 하는 경우 new를 통해 생성해서 setter()를 사용하지 말고 별도의 객체 생성 메서드를 별도로 만드는 방식으로
코드의 별도 제약을 두면서 설계하는 것이 추후 유지보수성, 가독성을 높일 수 있다. </br></br></br></br>




2-6. JPA의 장점</br>
(1) 데이터베이스 SQL을 직접 다루는 라이브러리인 mybatis, Jdbctemplate들은 데이터 변경 시 직접 서비스를 다루는 서비스 계층에서 
Transactional script(데이터베이스 상의 여러 작업을 묶어 하나의 트랜잭션에서 처리하는 것)를 모두 작성해 줘야 하는 번거로움이 있다.</br></br>

(2) 그러나 JPA를 사용하게 되면, 엔티티의 데이터만 변경해 줘도 JPA가 알아서 변경된 포인트들을 변경 감지를 통해 트랜잭션 커밋 시 데이터베이스에 관련된 쿼리를 모두 전송해준다. </br></br></br></br></br></br>




# 3. 웹 계층 개발 </br>
3-1. Bean Validation & BindingResult </br>
(1) Bean Validation의 경우 서버사이드에서 자바 어노테이션을 기반으로 필드에 대한 검증을 수행할 수 있는 라이브러리이다. </br></br>

(2) @NotNull, @NotEmpty</br>
- @NotNull의 경우 말 그대로 null 조건을 허용하지 않는다. 따라서 " ", "" 도 입력 가능하다.</br>
- @NotEmpty의 경우 공백을 허용하지 않는다.</br></br>

(3) BindingResult 객체 </br>
- 검증 과정에서 발생한 오류를 담는 객체로, 스프링에서 데이터 검증 및 바인딩 과정에서 발생한 오류를 담는 역할을 수행하며 controller 영역에서
  주로 사용된다. BindingResult를 통해 오류에 대한 후처리를 할 수 있게 된다.</br></br></br></br></br>




3-2. Model, @ModelAttribute, @PathVariable</br>
(1) Model </br>
- View, Controller 간의 데이터 전달을 위해 사용되는 객체 </br>
- 주로 Controller에서 View 영역으로 데이터를 전달할 때 사용한다. </br>
- 주로 addAttribute()를 통해 데이터를 Model에 추가하고 이를 View 영역에서 사용한다. </br> </br> </br>

(2) @ModelAttribute </br>
- Controller의 메서드 매개변수에 사용되는 어노테이션  </br></br>
- 메서드 매개변수에 해당 어노테이션 지정 시, 관련 객체를 자동으로 생성하고 요청 파라미터를 바인딩하여 전달한다. </br>
- 폼 입력값을 받거나 View -> Controller로 데이터 전달 시 사용 </br>
- 주로 해당 어노테이션을 사용해 Controller에서 Model 객체를 생성하고 초기화하게 된다. </br></br></br>

(3) @PathVariable</br>
- 요청 URL 경로 변수를 바인딩할 때 사용된다. </br>
- 경로 변수를 메서드 매개변수로 전달받아 Controller에서 사용할 수 있도록 함 </br>
- RESTful API에서 resource identifier를 전달할 때 사용한다. </br></br></br></br></br>




3-3. 엔티티는 최대한 순수하게 유지해야 한다. </br>
(1) 엔티티는 최대한 순수하게 유지하는 것이 중요하다. 특정 영역(화면 계층 등)에 종속되지 않고 핵심 비즈니스 로직에만
종속하도록 설계해야 한다.</br></br>

(2) 이러한 방식으로 설계해야 애플리케이션 복잡도가 증가하더라도, 엔티티를 여러 곳에서 많이 사용하더라도 유지보수성이 높아지게 된다. </br></br>

(3) 엔티티는 핵심 비즈니스 로직만 가지고 있고, 별도의 계층(화면 등)을 위한 로직은 존재하지 않아야 한다. </br>
(화면을 위한 로직, 화면에 맞는 API들은 폼 객체나 DTO(Data Transfer Object)를 사용하도록 한다. </br></br>

(4) API를 설계할 때는 엔티티를 그대로 외부에 직접 반환시키면 안 된다. API는 일종의 스펙이다. 
엔티티에 수정 사항이 생겨서 엔티티를 수정하면 해당 API의 스펙 자체가 변경되기 때문에 불완전한 API가 될 수 있다. </br>
(예외로 서버사이드 템플릿 엔진을 쓰는 경우 서버 안에서 데이터가 도는 것이기 때문에 엔티티 직접 반환 방법을 고려해볼만 하다 그렇다 하더라도 가장 권장되는 방법은
특정 목적에 맞는 DTO로 변환해서 반환하는 것이 좋다.)</br></br></br></br></br>




3-3. JPA에서 수정은 변경 감지(Dirty checking)를 사용하는 방법이 Best practice이다.</br>
(1) 참고로 특정 엔티티에 대한 ID값은 항상 조심해야 한다.
- @PathVariable로 바인딩 받은 아이디 값이 임의적으로 조작되어 넘겨받을 수도 있다. 이를 대비하기 위해 해당 아이디가
  서비스 계층의 앞단이나 뒷단에서 유저가 해당 엔티티에 대한 권한이 있는지 체크하는 로직이 서버사이드에 존재해야 한다. </br></br>

